CPU、IR--> Mem
       <->

# 工具
## 1.GDB
GDB 是 GNU Debugger 的缩写，它是一个用于Unix和Unix-like系统的强大的开源调试工具

插件：gdb-peda
- 使用：
1. 断点 `b main //在main入口处设置断点 `
2. 跑程序：`r`
3. 
# 随笔
1. _start真正开始执行C程序的地方
2. readelf -S

# x64
- registers(寄存器)
  - RAX RBX RCX RDX RDI RSI - 64 bi
  - RSP 指向stack顶端
  - RBP 指向stack底端
  - RIP 指向当前执行指令    instruction位置
- jmp
 - 跳转到程序某地址执行
 - jmp A =mov rip.A
- call
 - 将call完后回来紧接着要执行的下一行指令位置 push 到 stack 上储存起来，再跳过去执行。
   
 - call A =  push next_rip
   mov rip, A
- leave
 - 还原至 caller 的stack frame 。
 - mov rsp, rbp  pop rbp

- ret (return)
 - pop rip

x64 calling convention
- Pass parameters
 - rdi, rsi, rdx, rcx, r8, r9, (stack)
 - rdi, rsi, rdx, r10, r8, r9, (stack)
 - rax - store return value
 - x64 - register传参

 - x86 - stack传参

# Overflow(溢出)
- buffer overflow
 - gets(buf)
 - gets()不会检查输入长度

- stack overflow
- heap overflow
- 覆盖到理论上不应被修改的数据

# Canary
- Function prologue 时在 stack 上放置程序执行时 随机生成得 8 bytes 在 saved rbp 前，第一个 byte 为 null byte
- Function epilogue 时会拿储存在另一 segment 的值检查 canary 值是否相同（被修改）来检测 是否发生 overflow，若相同才正常 return，否则 直接终止程序 （Abort）
- 每次执行 canary 不同，同一次的 canary 固定

# Shellcode

# stack 栈
在计算机科学中，“栈”（stack）是一种重要的抽象数据类型，具有“后进先出”（LIFO，Last In First Out）的特性。这意味着最后被加入栈的元素会是第一个被移除的。==栈通常用于在程序中管理方法/函数调用的上下文，称为调用栈（call stack）或执行栈（execution stack）。==

- 通俗点讲：
想象一下，你在厨房做饭，每次你开始做一个新的菜品时，你都会把需要的食材和工具准备好，放在厨房台面上。如果在做这个菜的过程中，你突然想起来还要准备另一个小菜，你就会暂时把手头的活儿放一边，先去准备那个小菜。等小菜做好了，你再回来继续完成你之前的那个菜。这个过程可能会重复多次，直到所有的菜都做好了。

这个例子中的厨房台面，就像是计算机中的“调用栈”（Call Stack）。每当你开始做一个“菜”（也就是程序中的一个函数调用）时，计算机会在调用栈上“放置”这个函数需要的信息，比如你需要什么食材（函数的参数）和你停下来做到哪一步了（返回地址）。如果这个函数内部还调用了另一个函数，那么计算机就会在栈顶加上这个新函数的信息，等到这个新函数完成后，它的信息就会从栈上被“清理掉”，计算机再继续完成之前的那个函数。

调用栈就是这样一种结构，它帮助计算机跟踪目前正在执行的函数的点点滴滴。因为它是后进先出的结构，**最后调用的函数总是第一个完成并从栈中移除(类比堆书，最后堆得书在最上面，第一个拿走)**，这确保了函数的执行顺序是正确的。在你一层层深入调用不同的函数时，调用栈就像是在帮你记住每一步，确保你能够顺利地一步步完成任务，最后回到最开始的那个“菜”——也就是主函数。

在程序执行中，栈用于多种目的：

1. **函数调用和返回**：每当一个函数被调用时，其返回地址和有关的参数会被推送到调用栈上。一旦函数执行完成，它的返回值如果有的话，会被留在栈顶，之前的信息会被弹出栈，并返回到调用点。

2. **局部变量存储**：函数的局部变量通常存储在栈上，每个函数调用都会为其局部变量在栈上创建一个新的区域（也称为栈帧或激活记录）。

3. **保存寄存器状态**：在处理器架构中，栈经常被用来保存那些在函数调用期间需要被保护的寄存器的内容。

栈的工作方式简单说明：

- **push**：在栈顶增加一个元素。
- **pop**：移除栈顶的元素，并返回它。
- **peek/top**：查看栈顶的元素，但不移除它。

在大多数现代计算机架构中，调用栈是由操作系统和硬件共同管理的一块专门的内存，用于支持程序的嵌套调用和返回机制。在软件开发中，栈溢出（stack overflow）和栈不足（stack underflow）是常见的错误，分别指尝试从一个空栈中取值，或者栈空间不足以支持当前的数据存储需求。栈还经常被攻击者利用，比如在缓冲区溢出攻击中，通过在栈上写入数据来篡改控制流。

总的来说，栈是程序设计和计算机操作中的一个关键组成部分，提供了一种有效的数据管理和函数调用处理方式。

